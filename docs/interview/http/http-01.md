# 1. 应用层中常见的协议都有哪些？
应用层协议（application layer protocol）定义了运行在不同端系统上的应用程序进程如何相互传递报文。

应用层协议

1）DNS：一种用以将域名转换为IP地址的Internet服务，域名系统DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。

现在顶级域名TLD分为三大类：国家顶级域名nTLD；通用顶级域名gTLD；基础结构域名。

域名服务器分为四种类型：根域名服务器；顶级域名服务器；本地域名服务器；权限域名服务器。

2）FTP：文件传输协议FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。

基于客户服务器模式，FTP协议包括两个组成部分，一是FTP服务器，二是FTP客户端，提供交互式的访问面向连接，使用TCP/IP可靠的运输服务，主要功能：减少/消除不同操作系统下文件的不兼容性 。

3）telnet远程终端协议：telnet是一个简单的远程终端协议，它也是因特网的正式标准。又称为终端仿真协议。

4）HTTP：超文本传送协议，是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。

5）电子邮件协议SMTP：即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。

6）POP3：邮件读取协议，POP3(Post Office Protocol 3)协议通常被用来接收电子邮件。

7）远程登录协议(Telnet)：用于实现远程登录功能。

8）SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。

# 2. TCP 和 UDP 协议有什么区别？
1）基于连接

TCP是面向连接的协议，而UDP是无连接的协议。即TCP面向连接；UDP是无连接的，即发送数据之前不需要建立连接。

2）可靠性和有序性

TCP 提供交付保证（Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输），无差错，不丢失，不重复，且按序到达，也保证了消息的有序性。该消息将以从服务器端发出的同样的顺序发送到客户端，尽管这些消息到网络的另一端时可能是无序的。TCP协议将会为你排好序。

UDP不提供任何有序性或序列性的保证。UDP尽最大努力交付，数据包将以任何可能的顺序到达。

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

3）实时性

UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4）协议首部大小

TCP首部开销20字节；UDP的首部开销小，只有8个字节。

5）运行速度

TCP速度比较慢，而UDP速度比较快，因为TCP必须创建连接，以保证消息的可靠交付和有序性，毕竟TCP协议比UDP复杂。

6）拥塞机制

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，对实时应用很有用，如IP电话，实时视频会议等。

7）流模式（TCP）与数据报模式(UDP) TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的 。

8）资源占用

TCP对系统资源要求较多，UDP对系统资源要求较少。

TCP被认为是重量级的协议，而与之相比，UDP协议则是一个轻量级的协议。因为UDP传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。这也反映在用于承载元数据的头的大小。

9）应用

每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信 。基于UDP不需要建立连接，所以且适合多播的环境，UDP是大量使用在游戏和娱乐场所。

# 3. Socket 前后端通信是如何实现服务器集群？
假设有两台A服务器服务S1和B服务器服务S2，应用服务S0

首先你接收客户端（浏览器）请求的服务肯定是单点（一对一）连接，之后交给应用服务S0处理分配给两台服务器A和B上的服务S1和S2。

分配原则可以按一定的策略，如计数器等，按当前活跃连接数来决定分给哪台服务器。也可以更科学的按两台服务器实际处理的数据量来分配，因为有些连接可能一直空闲。

如果两台服务器上的服务通信正常且数据库能够承受压力，访问请求并不是太多的情况下，可以考虑使用数据库传递消息，反之可以考虑使用Redis缓存技术。

如果需要即时传递消息，在其中一个服务器上的服务S1查找不到，把消息发给另外一台服务器上的服务S2或把消息存储至数据库或缓存当中，然后通知其他服务有生产消息。类似MQ处理方式可参考ActiveMQ。

# 4. HTTP1.0 和 HTTP1.1 有什么区别？
1）长连接（Persistent Connection）

HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

HTTP1.1支持长连接，在请求头中有Connection：Keep-Alive。在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

2）节省带宽

HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象传输过去，并且不支持断点续传功能。

HTTP1.1支持只发送header信息，不携带其他任何body信息，如果服务器认为客户端有权限请求服务器，则返回100状态码，客户端接收到100状态码后把请求body发送到服务器；如果返回401状态码，客户端无需发送请求body节省带宽。

3）HOST域

HTTP1.0没有host域，HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。

HTTP1.1的请求消息和响应消息都支持host域，且请求消息中若是host域会报告400 Bad Request错误。一台物理服务器上可以同时存在多个虚拟主机（Multi-homed Web Servers），并且它们可以共享一个IP地址。

4）缓存处理

HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准。

HTTP1.1引入了更多的缓存控制策略如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。

5）错误通知管理

HTTP1.1中新增24个错误状态响应码，比如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

# 5. HTTP1.1 和 HTTP2.0 有什么区别？
1）多路复用

HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。

HTTP1.1可以建立多个TCP连接来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。

2）头部数据压缩

HTTP1.1中HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。

一般而言，消息主体都会经过gzip压缩或本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。

随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie等不会频繁变动的内容，完全是一种浪费资源的体现。

HTTP1.1不支持header数据的压缩，而HTTP2.0使用HPACK算法对header的数据进行压缩，压缩的数据体积小，在网络上传输更快。

3）服务器推送

服务端推送是一种在客户端请求前发送数据的机制。

网页中使用了许多资源：HTML、样式表、脚本、图片等，在HTTP1.1中这些资源每一个都必须明确地请求，这是一个很慢的过程。

浏览器从获取HTML开始，然后在它解析和评估页面时获取更多的资源，因为服务器必须等待浏览器做每一个请求，网络经常是空闲和未充分使用的。

HTTP2.0引入了server push，允许服务端推送资源给浏览器，在浏览器明确请求前，不用客户端再次创建连接发送请求到服务器端获取，客户端可以直接从本地加载这些资源，不用再通过网络。

# 6. 同步、异步、阻塞、非阻塞概念是什么？
同步是指函数调用在没得到结果之前，没有调用结果，不返回任何结果。

异步是指函数调用在没得到结果之前，没有调用结果，返回状态信息。

阻塞是指函数调用在没得到结果之前，当前线程挂起。得到结果后才返回。

非阻塞是指函数调用在没得到结果之前，当前线程不会挂起，立即返回结果。

# 7. 什么是 Java 序列化（串行化）？
序列化是指一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

简单来说就是为了保存在内存中各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。

序列化的实现是将需要被序列化的类实现Serializable接口，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream（对象流）对象，然后使用ObjectOutputStream对象的writeObject（Object obj）方法就可以将参数为obj的对象写出（即保存其状态），要想恢复的话需要使用输入流。

# 8. 序列化都有哪些使用场景？
对象的序列化目的是把一个具体的对象进行持久化，写入到硬盘上。但是需要注意的是静态数据不可以被序列化，这是因为静态数据不在堆内存当中，而是在静态方法区当中。

Serializable用来启动对象的序列化功能，能够强制让指定类具备序列化功能，这个接口当中没有成员，这是只是一个标记接口，用来给序列化类提供UID。

使用场景

1）当需要把内存中的对象状态保存到一个文件或数据库中时可以使用序列化；

2）当需要用套接字在网络上传送对象时可以使用序列化；

3）当需要通过RMI传输对象时可以使用序列化。

# 9. 序列化使用都有哪些注意事项？
1、如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。

2、静态变量不会被序列化，串行化保存的是对象状态，即非静态属性或实例变量，不能保存类变量。

3、transient关键字修饰变量可以限制序列化。对于不需要或不应该保存的属性，应加上transient修饰符。要串行化的对象的类必须是公开的（public）。

4、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID是否一致，就是 private static final long serialVersionUID = 1L。

5、Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。反序列化时，恢复引用关系。

6、序列化到同一个文件时，在第二次修改相同对象属性值再次保存时，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时都是第一次保存的对象。

# 10. TCP/IP连接时有几次握手？释放几次？
建立时三次握手

为了双方都互相知道已经准备好进行数据传输，确认一个初始传输序列号，以免产生错误的连接。

1）第一次握手

客户端：将标志位SYN（SYN：同步序列编号）置为1，并产生一个同步值（seq=j），将数据包发送到服务器,并使自己处于SYN_SENT状态，等待服务器确认。

2）第二次握手

服务端: 收到客户端发来的数据包，由SYN标志位为1知道客户端请求建立连接，知道同步值seq=j后，将自己的SYN和ACK置为1，产生一个确认包ack=j+1，同时产生一个同步值seq=k，然后发送数据包，并使自己处于SYN_RECV状态（接收状态）。

3）第三次握手

客户端： 收到服务端发来的数据包，将自己的ACK（接收状态）置为1，并产生一个确认包ack=k+1，然后发送数据包，此时双方同时处于SYN_ESTABLISHED状态，建立连接，等待发送和接收数据，完成三次握手。

释放时四次挥手

第一次挥手

客户端将自己的FIN置为1（意思为关闭连接，自己这边没有发送的数据了），同时产生一个同步值seq=u，将数据包发送给服务器。

第二次挥手

服务器收到以后，由于可能还没有发送完自己的数据，先将自己的ACK置为1（回应状态，意思知道了），并产生一个确认包ack=u+1，并产生一个同步值v，将数据包发送给客户端。

第三次挥手

服务器发送完没有发送的数据后，将自己的FIN置为1（意思可以关闭连接），ACK置为1（回应状态，意思收到），并产生一个同步值w，产生确认包ack=u+1(基于客户端的，跟上一次一样，因为客户端只发送了一次）。

第四次挥手

客户端收到，将自己的ACK置为1（收到），产生一个确认包ack=w+1，还有一个同步值seq=u+1，将自己的数据报发送给服务器。

# 11. HTTP 协议中常用的请求方法有哪些？
根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法：GET、POST和HEAD方法。

HTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE和CONNECT方法。

| 方法	| 描述	| 是否包含主体 | 
| --------------------	| --------------------|--------|
| GET	| 请求指定的页面信息，并返回实体主体。	| 否      |
| HEAD	| 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头	| 否      |
| POST	| 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。	| 是      |
| PUT	| 从客户端向服务器传送的数据取代指定的文档的内容。	| 是      |
| TRACE	| 回显服务器收到的请求，主要用于测试或诊断	| 否      |
| OPTIONS	| 允许客户端查看服务器的性能。	| 否      |
| DELETE	| 请求服务器删除指定的页面。	| 否      |
| CONNECT	| HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。	| 否      |
# 12. HTTP 状态码常见的都有哪些？
当浏览者访问网页时，浏览器会向网页所在服务器发出请求。浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。

HTTP状态码的英文为HTTP Status Code。

下面是常见的HTTP状态码：

200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。

HTTP状态码共分为5种类型：

“1**”状态码表示信息，服务器收到请求，需要请求者继续执行操作。

“2**”状态码表示成功，操作被成功接收并处理。

“3**”状态码表示重定向，需要进一步的操作以完成请求。

“4**”状态码表示客户端错误，请求包含语法错误或无法完成请求。

“5**”状态码表示服务器错误，服务器在处理请求的过程中发生了错误。

# 13. 什么是网络协议？
网络协议(Protocol)是一种特殊的软件，是计算机网络实现其功能的最基本机制。

网络协议的本质是规则，即各种硬件和软件必须遵循的共同守则。

网络协议并不是一套单独的软件，它融合于其他所有的软件系统中，因此可以说，协议在网络中无所不在。

网络协议遍及OSI通信模型的各个层次，从我们非常熟悉的TCP/IP、HTTP、FTP协议，到OSPF、IGP等协议，有上千种之多。

对于普通用户而言，不需要关心太多的底层通信协议，只需要了解其通信原理即可。

在实际管理中，底层通信协议一般会自动工作，不需要人工干预。但是对于第三层以上的协议，就经常需要人工干预，比如TCP/IP协议就需要人工配置才能正常工作。

局域网常用的三种通信协议分别是TCP/IP协议、NetBEUI协议和IPX/SPX协议。

# 14. 网络传输协议本质和作用是什么？
协议本质是双方约定好的一种传输规则，其作用是为了让传输数据的双方节点能建立连接，按照约定去传输和解析数据。

# 15. 为什么要对网络协议分层？
1、简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。

2、灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。

3、易于实现和维护。

4、促进标准化工作。分开后，每层功能可以相对简单地被描述。

# 16. 什么是应用层？
应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。

# 17. 什么是传输层？
传输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。

传输层主要使用一下两种协议：

1）传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。 2）用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

| UDP	| TCP|
| --------------------	| --------------------|
| 是否连接	| 无连接|
| 是否可靠	| 不可靠传输，不使用流量控制和拥塞控制|
| 连接对象个数	| 支持一对一，一对多，多对一和多对多交互通信|
| 传输方式	| 面向报文|
| 首部开销	| 首部开销小，仅8字节|
场景	适用于实时应用（IP电话、视频会议、直播等）
# 18. 什么是网络层？
网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报 ，简称数据报。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。

发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

# 19. 什么是数据链路层？
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

# 20. 什么是物理层？
在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

使其上面的数据链路层不必考虑网络的具体传输介质是什么。

“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。
